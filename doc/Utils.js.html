<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>JClic.js Source: Utils.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.united.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">JClic.js</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-JClic.html">JClic</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="AbstractBox.html">AbstractBox</a></li><li><a href="Action.html">Action</a></li><li><a href="ActionReg.html">ActionReg</a></li><li><a href="ActiveBagContent.html">ActiveBagContent</a></li><li><a href="ActiveBox.html">ActiveBox</a></li><li><a href="ActiveBoxBag.html">ActiveBoxBag</a></li><li><a href="ActiveBoxContent.html">ActiveBoxContent</a></li><li><a href="ActiveBoxGrid.html">ActiveBoxGrid</a></li><li><a href="ActiveMediaBag.html">ActiveMediaBag</a></li><li><a href="ActiveMediaPlayer.html">ActiveMediaPlayer</a></li><li><a href="Activity.html">Activity</a></li><li><a href="ActivityPanel.html">ActivityPanel</a></li><li><a href="ActivityReg.html">ActivityReg</a></li><li><a href="ActivitySequence.html">ActivitySequence</a></li><li><a href="ActivitySequenceElement.html">ActivitySequenceElement</a></li><li><a href="ActivitySequenceJump.html">ActivitySequenceJump</a></li><li><a href="Arith.html">Arith</a></li><li><a href="Arith.Operator.html">Arith.Operator</a></li><li><a href="AudioBuffer.html">AudioBuffer</a></li><li><a href="AutoContentProvider.html">AutoContentProvider</a></li><li><a href="AutoContentProvider.ActiveBagContentKit.html">AutoContentProvider.ActiveBagContentKit</a></li><li><a href="BasicEvaluator.html">BasicEvaluator</a></li><li><a href="BlueSkin.html">BlueSkin</a></li><li><a href="BoxBag.html">BoxBag</a></li><li><a href="BoxBase.html">BoxBase</a></li><li><a href="BoxConnector.html">BoxConnector</a></li><li><a href="ClassicJigSaw.html">ClassicJigSaw</a></li><li><a href="Complete.html">Complete</a></li><li><a href="CompletePanel.html">CompletePanel</a></li><li><a href="ComplexAssociation.html">ComplexAssociation</a></li><li><a href="ComplexAssociationPanel.html">ComplexAssociationPanel</a></li><li><a href="ComplexEvaluator.html">ComplexEvaluator</a></li><li><a href="ConditionalJumpInfo.html">ConditionalJumpInfo</a></li><li><a href="Container.html">Container</a></li><li><a href="Counter.html">Counter</a></li><li><a href="CrossWord.html">CrossWord</a></li><li><a href="CrossWordPanel.html">CrossWordPanel</a></li><li><a href="CustomSkin.html">CustomSkin</a></li><li><a href="DefaultSkin.html">DefaultSkin</a></li><li><a href="Dimension.html">Dimension</a></li><li><a href="DoublePuzzle.html">DoublePuzzle</a></li><li><a href="DoublePuzzlePanel.html">DoublePuzzlePanel</a></li><li><a href="Ellipse.html">Ellipse</a></li><li><a href="EmptySkin.html">EmptySkin</a></li><li><a href="Encryption.html">Encryption</a></li><li><a href="Evaluator.html">Evaluator</a></li><li><a href="EventSounds.html">EventSounds</a></li><li><a href="EventSoundsElement.html">EventSoundsElement</a></li><li><a href="ExchangePuzzle.html">ExchangePuzzle</a></li><li><a href="ExchangePuzzlePanel.html">ExchangePuzzlePanel</a></li><li><a href="Explore.html">Explore</a></li><li><a href="ExplorePanel.html">ExplorePanel</a></li><li><a href="FillInBlanks.html">FillInBlanks</a></li><li><a href="FillInBlanksPanel.html">FillInBlanksPanel</a></li><li><a href="Font.html">Font</a></li><li><a href="Gradient.html">Gradient</a></li><li><a href="GreenSkin.html">GreenSkin</a></li><li><a href="HolePuzzle.html">HolePuzzle</a></li><li><a href="HolePuzzlePanel.html">HolePuzzlePanel</a></li><li><a href="Holes.html">Holes</a></li><li><a href="Identify.html">Identify</a></li><li><a href="IdentifyPanel.html">IdentifyPanel</a></li><li><a href="IdentifyText.html">IdentifyText</a></li><li><a href="IdentifyTextPanel.html">IdentifyTextPanel</a></li><li><a href="InformationScreen.html">InformationScreen</a></li><li><a href="InformationScreenPanel.html">InformationScreenPanel</a></li><li><a href="JClicPlayer.html">JClicPlayer</a></li><li><a href="JClicProject.html">JClicProject</a></li><li><a href="JigSaw.html">JigSaw</a></li><li><a href="JumpInfo.html">JumpInfo</a></li><li><a href="MediaBag.html">MediaBag</a></li><li><a href="MediaBagElement.html">MediaBagElement</a></li><li><a href="MediaContent.html">MediaContent</a></li><li><a href="MemoryGame.html">MemoryGame</a></li><li><a href="MemoryGamePanel.html">MemoryGamePanel</a></li><li><a href="Menu.html">Menu</a></li><li><a href="MenuPanel.html">MenuPanel</a></li><li><a href="MiniSkin.html">MiniSkin</a></li><li><a href="OrangeSkin.html">OrangeSkin</a></li><li><a href="OrderText.html">OrderText</a></li><li><a href="OrderTextPanel.html">OrderTextPanel</a></li><li><a href="Path.html">Path</a></li><li><a href="PathStroke.html">PathStroke</a></li><li><a href="PlayerHistory.html">PlayerHistory</a></li><li><a href="PlayerHistory_HistoryElement.html">PlayerHistory#HistoryElement</a></li><li><a href="Point.html">Point</a></li><li><a href="ProjectSettings.html">ProjectSettings</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="Rectangular.html">Rectangular</a></li><li><a href="ReportBean.html">ReportBean</a></li><li><a href="Reporter.html">Reporter</a></li><li><a href="ReporterInfo.html">ReporterInfo</a></li><li><a href="SCORM.html">SCORM</a></li><li><a href="SequenceReg.html">SequenceReg</a></li><li><a href="SequenceRegInfo.html">SequenceRegInfo</a></li><li><a href="SessionReg.html">SessionReg</a></li><li><a href="SessionRegInfo.html">SessionRegInfo</a></li><li><a href="SessionStorageReporter.html">SessionStorageReporter</a></li><li><a href="Shape.html">Shape</a></li><li><a href="Shaper.html">Shaper</a></li><li><a href="SimpleAssociation.html">SimpleAssociation</a></li><li><a href="SimpleAssociationPanel.html">SimpleAssociationPanel</a></li><li><a href="SimpleSkin.html">SimpleSkin</a></li><li><a href="Skin.html">Skin</a></li><li><a href="Stroke.html">Stroke</a></li><li><a href="TCPReporter.html">TCPReporter</a></li><li><a href="TextActivityBase.html">TextActivityBase</a></li><li><a href="TextActivityBasePanel.html">TextActivityBasePanel</a></li><li><a href="TextActivityDocument.html">TextActivityDocument</a></li><li><a href="TextGrid.html">TextGrid</a></li><li><a href="TextGridContent.html">TextGridContent</a></li><li><a href="TextTarget.html">TextTarget</a></li><li><a href="Timer.html">Timer</a></li><li><a href="TriangularJigSaw.html">TriangularJigSaw</a></li><li><a href="Utils.html">Utils</a></li><li><a href="WordSearch.html">WordSearch</a></li><li><a href="WordSearchPanel.html">WordSearchPanel</a></li><li><a href="WrittenAnswer.html">WrittenAnswer</a></li><li><a href="WrittenAnswerPanel.html">WrittenAnswerPanel</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="externals.list.html" class="dropdown-toggle" data-toggle="dropdown">Externals<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="external-CanvasRenderingContext2D.html">CanvasRenderingContext2D</a></li><li><a href="external-Collator.html">Collator</a></li><li><a href="external-HTMLAudioElement.html">HTMLAudioElement</a></li><li><a href="external-HTMLElement.html">HTMLElement</a></li><li><a href="external-HTMLImageElement.html">HTMLImageElement</a></li><li><a href="external-i18next.html">i18next</a></li><li><a href="external-jQuery.html">jQuery</a></li><li><a href="external-jqXHR.html">jqXHR</a></li><li><a href="external-JSZip.html">JSZip</a></li><li><a href="external-MediaRecorder.html">MediaRecorder</a></li><li><a href="external-NamedNodeMap.html">NamedNodeMap</a></li><li><a href="external-Promise.html">Promise</a></li><li><a href="external-Storage.html">Storage</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: Utils.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/**
 *  File    : Utils.js
 *  Created : 01/04/2015
 *  By      : Francesc Busquets &lt;francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.1
 *  @licstart
 *  (c) 2000-2018 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 */

/* global define */

define([
  "jquery",
  "screenfull",
  "clipboard-js",
  "i18next",
  "jszip",
  "jszip-utils",
  "scriptjs",
  "webfontloader"
], function ($, screenfull, clipboard, i18next, JSZip, JSZipUtils, ScriptJS, WebFont) {

  // In some cases, require.js does not return a valid value for screenfull. Check it:
  if (!screenfull)
    screenfull = window.screenfull

  /**
   * Returns the two-digits text expression representing the given number (lesser than 100) zero-padded at left
   * Useful for representing hours, minutes and seconds
   * @param {number} val - The number to be processed
   * @returns {string}
   */
  const _zp = val => `0${val}`.slice(-2)

  /**
   *
   * Miscellaneous utility functions and constants
   * @exports Utils
   * @class
   * @abstract
   */
  const Utils = {
    /**
     * Exports third-party NPM packages used by JClic, so they become available to other scripts through
     * the global variable `JClicObject` (defined in {@link JClic})
     * @example &lt;caption>Example usage of JSZip through JClicObject&lt;/caption>
     * var WebFont = window.JClicObject.Utils.pkg.WebFont;
     * WebFont.load({google: {families: ['Roboto']}});
     * @type: {object} */
    pkg: {
      ClipboardJS: clipboard,
      i18next: i18next,
      $: $,
      JSZip: JSZip,
      JSZipUtils: JSZipUtils,
      ScriptJS: ScriptJS,
      WebFont: WebFont,
    },
    /**
     * Function obtained from `i18next` that will return the translation of the provided key
     * into the current language.
     * The real function will be initiated by the constructor of `JClicPlayer`. Meanwhile, it returns always `key`.
     * @param {string} key - ID of the expression to be translated
     * @returns {string} - Translated text
     */
    getMsg: key => key,
    /**
     * List of valid verbosity levels
     * @const {string[]} */
    LOG_LEVELS: ['none', 'error', 'warn', 'info', 'debug', 'trace', 'all'],
    /**
     * Labels printed on logs for each message type
     * @const {string[]}
     */
    LOG_PRINT_LABELS: ['     ', 'ERROR', 'WARN ', 'INFO ', 'DEBUG', 'TRACE', 'ALL  '],
    /**
     * Current verbosity level. Default is 2 (only error and warning messages are printed)
     * @type {number} */
    LOG_LEVEL: 2, // warn
    /**
     * Options of the logging system
     * @type {object} */
    LOG_OPTIONS: {
      prefix: 'JClic',
      timestamp: true,
      popupOnErrors: false,
      chainTo: null,
      pipeTo: null,
    },
    /**
     * Initializes the global settings
     * @param {object} options - An object with global settings
     * @returns {object} The normalized `options` object
     */
    init: options => {
      options = Utils.normalizeObject(options)
      if (typeof options.logLevel !== 'undefined')
        Utils.setLogLevel(options.logLevel)
      if (typeof options.chainLogTo === 'function')
        Utils.LOG_OPTIONS.chainTo = options.chainLogTo
      if (typeof options.pipeLogTo === 'function')
        Utils.LOG_OPTIONS.pipeTo = options.pipeLogTo
      return options
    },
    /**
     * Establishes the current verbosity level of the logging system
     * @param {string} level - One of the valid strings in {@link Utils.LOG_LEVELS}
     */
    setLogLevel: level => {
      const log = Utils.LOG_LEVELS.indexOf(level)
      if (log >= 0)
        Utils.LOG_LEVEL = log
    },
    /**
     * Reports a new message to the logging system
     * @param {string} type - The type of message. Mus be `error`, `warn`, `info`, `debug` or `trace`.
     * @param {string} msg - The main message to be logged. Additional parameters can be added, like
     * in `console.log` (see: {@link https://developer.mozilla.org/en-US/docs/Web/API/Console/log})
     */
    log: function (type, msg) {
      const level = Utils.LOG_LEVELS.indexOf(type)
      const args = Array.prototype.slice.call(arguments)

      // Check if message should currently be logged
      if (level &lt; 0 || level &lt;= Utils.LOG_LEVEL) {
        if (Utils.LOG_OPTIONS.pipeTo)
          Utils.LOG_OPTIONS.pipeTo.apply(null, args)
        else {
          const mainMsg = `${Utils.LOG_OPTIONS.prefix || ''} ${Utils.LOG_PRINT_LABELS[level]} ${Utils.LOG_OPTIONS.timestamp ? Utils.getDateTime() : ''} ${msg}`
          console[level === 1 ? 'error' : level === 2 ? 'warn' : 'log'].apply(console, [mainMsg].concat(args.slice(2)))
          // Call chained logger, if anny
          if (Utils.LOG_OPTIONS.chainTo)
            Utils.LOG_OPTIONS.chainTo.apply(null, args)
        }
      }
    },
    /**
     * Gets a boolean value from a textual expression
     * @param {string} val - The value to be parsed (`true` for true, null or otherwise for `false`)
     * @param {boolean=} [defaultValue=false] - The default value to return when `val` is false
     * @returns {number}
     */
    getBoolean: (val, defaultValue = false) => val === 'true' ? true : val === 'false' ? false : defaultValue,
    /**
     * Gets a value from an given expression that can be `null`, `undefined` or empty string ('')
     * @param {?*} val - The expression to parse
     * @param {?*} [defaultValue=null] - The value to return when `val` is `null`, `''` or `undefined`
     * @returns {*}
     */
    getVal: (val, defaultValue = null) => (val === '' || val === null || typeof val === 'undefined') ? defaultValue : val,
    /**
     * Gets a number from a string or another number
     * @param {?*} val - The expression to parse
     * @param {number} [defaultValue=0] - The default value
     * @returns {number}
     */
    getNumber: (val, defaultValue) => Number(Utils.getVal(val, defaultValue)),
    /**
     * Gets the plain percent expression (without decimals) of the given value
     * @param {number} val - The value to be expressed as a percentile
     * @returns {string}
     */
    getPercent: val => `${Math.round(val * 100)}%`,
    /**
     * Returns a given time in [00h 00'00"] format
     * @param {number} millis - Amount of milliseconds to be processed
     * @returns {string}
     */
    getHMStime: millis => {
      const d = new Date(millis)
      const h = d.getUTCHours(), m = d.getUTCMinutes(), s = d.getUTCSeconds()
      return `${h ? h + 'h ' : ''}${h || m ? _zp(m) + '\'' : ''}${_zp(s)}"`
    },
    /**
     * Returns a formatted string with the provided date and time
     * @param {Date} date - The date to be formatted. When `null` or `undefined`, the current date will be used.
     * @returns {string}
     */
    getDateTime: (date = new Date()) => `${date.getFullYear()}/${_zp(date.getMonth() + 1)}/${_zp(date.getDate())} ${_zp(date.getHours())}:${_zp(date.getMinutes())}:${_zp(date.getSeconds())}`,
    /** @const {number} */
    'FALSE': 0,
    /** @const {number} */
    'TRUE': 1,
    /** @const {number} */
    'DEFAULT': 2,
    /**
     * Gets a numeric value (0, 1 or 2) from a set of possible values: `false`, `true` and `default`.
     * @param {?string} val - The text to be parsed
     * @returns {number}
     */
    getTriState: val => val === 'true' ? Utils.TRUE : val === 'false' ? Utils.FALSE : Utils.DEFAULT,
    /**
     * Returns a string with the given `tag` repeated n times
     * @param {string} tag - The tag to be repeated
     * @param {number} repeats - The number of times to repeat the tag
     * @returns {string}
     */
    fillString: (tag, repeats = 0) => Array(repeats).fill(tag).join(''),
    /**
     * Checks if the provided value is 'null' or 'undefined'.
     * @param {*} val - The value to be parsed
     * @returns {boolean}
     */
    isNullOrUndef: val => typeof val === 'undefined' || val === null,
    /**
     * Checks if two expressions are equivalent.
     * Returns `true` when both parameters are `null` or `undefined`, and also when both have
     * equivalent values.
     * @param {!*} a
     * @param {!*} b
     * @returns {boolean}
     */
    isEquivalent: (a, b) => (typeof a === 'undefined' || a === null) &amp;&amp; (typeof b === 'undefined' || b === null) || a === b,
    /**
     * Reads paragraphs, identified by `&lt;p>&lt;/p>` elements, inside XML data
     * @param {object} xml - The DOM-XML element to be parsed
     * @returns {string}
     */
    getXmlText: xml => {
      let text = ''
      $(xml).children('p').each((_n, child) => { text += `&lt;p>${child.textContent}&lt;/p>` })
      return text
    },
    /**
     * Parses the provided XML element node, returning a complex object
     * @param {object} xml - The root XML element to parse
     * @returns {object}
     */
    parseXmlNode: xml => {
      // Initialize the resulting object
      const result = {}
      // Direct copy of root element attributes as object properties
      if (xml.attributes)
        Utils.attrForEach(xml.attributes, (name, value) => result[name] = /^-?\d*$/.test(value) ? Number(value) : value)
      // Process children elements
      const keys = []
      for (let n = 0; n &lt; xml.children.length; n++) {
        const child = xml.children[n]
        // Recursive processing of children
        const ch = Utils.parseXmlNode(child)
        // Store the result into a temporary object named as the child node name,
        if (!result[child.nodeName]) {
          // Create object and save key for later processing
          result[child.nodeName] = {}
          keys.push(child.nodeName)
        }
        // Use 'id' (or an incremental number if 'id' is not set) as a key
        if (ch.id)
          result[child.nodeName][ch.id] = ch
        else {
          const n = Object.keys(result[child.nodeName]).length
          result[child.nodeName][n] = ch
        }
      }
      // Check temporary objects, converting it to an array, a single object or a complex object
      keys.forEach(k => {
        // Retrieve temporary object from `keys`
        const kx = Object.keys(result[k])
        // If all keys are numbers, convert object into an array (or leave it as a single object)
        if (!kx.find(kk => isNaN(kk))) {
          if (kx.length === 1)
            // Array with a single element. Leave it as a simple object:
            result[k] = result[k][0]
          else {
            // Object with numeric keys. Convert it to array:
            const arr = []
            kx.forEach(kk => arr.push(result[k][kk]))
            result[k] = arr
          }
        }
      })
      // Save text content, if any:
      if (xml.children.length === 0 &amp;&amp; xml.textContent)
        result.textContent = xml.textContent
      return result
    },
    /**
     * Creates a string suitable to be used in the 'style' attribute of HTML tags, filled with the
     * CSS attributes contained in the provided object.
     * @param {object} cssObj
     * @returns {string}
     */
    cssToString: cssObj => Object.keys(cssObj).reduce((s, key) => `${s}${key}:${cssObj[key]};`, ''),
    /**
     * Converts java-like color codes (like '0xRRGGBB') to valid CSS values like '#RRGGBB' or 'rgba(r,g,b,a)'
     * @param {string=} color - A color, as codified in Java
     * @param {string=} defaultColor - The default color to be used
     * @returns {string}
     */
    checkColor: (color, defaultColor = Utils.settings.BoxBase.BACK_COLOR) => {
      if (typeof color === 'undefined' || color === null)
        color = defaultColor
      color = color.replace('0x', '#')
      // Check for Alpha value
      if (color.charAt(0) === '#' &amp;&amp; color.length > 7) {
        const alpha = parseInt(color.substring(1, 3), 16) / 255.0
        color = `rgba(${parseInt(color.substring(3, 5), 16)},${parseInt(color.substring(5, 7), 16)},${parseInt(color.substring(7, 9), 16)},${alpha})`
      }
      return color
    },
    /**
     * Checks if the provided color has an alpha value less than 1
     * @param {string} color - The color to be analyzed
     * @returns {boolean}
     */
    colorHasTransparency: color => {
      if (Utils.startsWith(color, 'rgba(')) {
        var alpha = parseInt(color.substr(color.lastIndexOf(',')))
        return typeof alpha === 'number' &amp;&amp; alpha &lt; 1.0
      }
      return false
    },
    /**
     * Clones the provided object
     * See: https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance
     * @param {object} obj
     * @returns {object}
     */
    //cloneObject: obj => Object.assign(Object.create(Object.getPrototypeOf(obj)), obj),
    cloneObject: obj => $.extend(true, Object.create(Object.getPrototypeOf(obj)), obj),
    /**
     * Converts string values to number or boolean when needed
     * @param {Object} obj - The object to be processed
     * @returns {Object} - A new object with normalized content
     */
    normalizeObject: obj => {
      const result = {}
      if (obj)
        $.each(obj, (key, value) => {
          let s
          if (typeof value === 'string' &amp;&amp; (s = value.trim().toLowerCase()) !== '')
            value = s === 'true' ? true : s === 'false' ? false : isNaN(s) ? value : Number(s)
          result[key] = value
        })
      return result
    },
    /**
     * Check if the given char is a separator
     * @param {string} ch - A string with a single character
     * @returns {boolean}
     */
    isSeparator: ch => ' .,;-|'.includes(ch),
    /**
     * Rounds `v` to the nearest multiple of `n`
     * @param {number} v
     * @param {number} n - Cannot be zero!
     * @returns {number}
     */
    roundTo: (v, n) => Math.round(v / n) * n,
    /**
     * Compares the provided answer against multiple valid options. These valid options are
     * concatenated in a string, separated by pipe chars (`|`). The comparing can be case sensitive.
     * @param {string} answer - The text to check against to
     * @param {string} check - String containing one or multiple options, separated by `|`
     * @param {boolean} checkCase - When true, the comparing will be case-sensitive
     * @returns {boolean}
     */
    compareMultipleOptions: (answer, check, checkCase) => {
      if (answer === null || answer.length === 0 || check === null || check.length === 0)
        return false
      if (!checkCase)
        answer = answer.toUpperCase()
      answer = answer.trim()
      for (let token of check.split('|')) {
        if (answer === (checkCase ? token : token.toUpperCase()).trim())
          return true
      }
      return false
    },
    /**
     * Checks if the given string ends with the specified expression
     * @param {string} text - The string where to find the expression
     * @param {string} expr - The expression to search for.
     * @param {boolean=} trim - When `true`, the `text` string will be trimmed before check
     * @returns {boolean}
     */
    endsWith: (text = '', expr, trim) => typeof text === 'string' &amp;&amp; (trim ? text.trim() : text).endsWith(expr),
    /**
     * Checks if the given string starts with the specified expression
     * @param {string} text - The string where to find the expression
     * @param {string} expr - The expression to search for.
     * @param {boolean=} trim - When `true`, the `text` string will be trimmed before check
     * @returns {boolean}
     */
    startsWith: (text = '', expr, trim) => typeof text === 'string' &amp;&amp; (trim ? text.trim() : text).indexOf(expr) === 0,
    /**
     * Replaces all occurrences of the backslash character (`\`) by a regular slash (`/`)
     * This is useful to normalize bad path names present in some old JClic projects
     * @param {String} str - The string to be normalized
     * @returns {string}
     */
    nSlash: str => str ? str.replace(/\\/g, '/') : str,
    /**
     * Checks if the given expression is an absolute URL
     * @param {string} exp - The expression to be checked
     * @returns {boolean}
     */
    isURL: exp => /^(filesystem:)?(https?|file|data|ftps?):/i.test(exp),
    /**
     * Gets the base path of the given file path (absolute or full URL). This base path always ends
     * with `/`, meaning it can be concatenated with relative paths without adding a separator.
     * @param {type} path - The full path to be parsed
     * @returns {string}
     */
    getBasePath: path => {
      const p = path.lastIndexOf('/')
      return p >= 0 ? path.substring(0, p + 1) : ''
    },
    /**
     * Gets the full path of `file` relative to `basePath`
     * @param {string} file - The file name
     * @param {string=} path - The base path
     * @returns {string}
     */
    getRelativePath: (file, path) => (!path || path === '' || file.indexOf(path) !== 0) ? file : file.substr(path.length),
    /**
     * Gets the complete path of a relative or absolute URL, using the provided `basePath`
     * @param {string} basePath - The base URL
     * @param {string} path - The filename
     * @returns {string}
     */
    getPath: (basePath, path) => Utils.isURL(path) ? path : basePath + path,
    /**
     * Gets a promise with the complete path of a relative or absolute URL, using the provided `basePath`
     * @param {string} basePath - The base URL
     * @param {string} path - The filename
     * @param {?external:JSZip} zip - An optional {@link external:JSZip} object where to look
     * for the file
     * @returns {Promise}
     */
    getPathPromise: (basePath, path, zip) => {
      if (zip) {
        const fName = Utils.getRelativePath(basePath + path, zip.zipBasePath)
        if (zip.files[fName]) {
          return new Promise((resolve, reject) => {
            zip.file(fName).async('base64').then(data => {
              const ext = path.toLowerCase().split('.').pop()
              const mime = Utils.settings.MIME_TYPES[ext] || 'application/octet-stream'
              resolve(`data:${mime};base64,${data}`)
            }).catch(reject)
          })
        }
      }
      return Promise.resolve(Utils.getPath(basePath, path))
    },
    /**
     * Utility object that provides several methods to build simple and complex DOM objects
     * @type {object}
     */
    $HTML: {
      doubleCell: (a, b) => $('&lt;tr/>').append($('&lt;td/>').html(a)).append($('&lt;td/>').html(b)),
      p: txt => $('&lt;p/>').html(txt),
      td: (txt, className) => $('&lt;td/>', className ? { class: className } : null).html(txt),
      th: (txt, className) => $('&lt;th/>', className ? { class: className } : null).html(txt),
    },
    /**
     * Checks if the current browser allows to put HTML elements in full screen mode
     * @returns {boolean}
     */
    screenFullAllowed: () => screenfull &amp;&amp; screenfull.enabled,
    /**
     * Replaces `width`, `height` and `fill` attributes of a simple SVG image
     * with the provided values
     * @param {string} svg - The SVG image as XML string
     * @param {string=} width - Optional setting for "width" property
     * @param {string=} height - Optional setting for "height" property
     * @param {string=} fill - Optional setting for "fill" property
     * @returns {string} - The resulting svg code
     */
    getSvg: (svg, width, height, fill) => {
      if (width)
        svg = svg.replace(/width=\"\d*\"/, `width="${width}"`)
      if (height)
        svg = svg.replace(/height=\"\d*\"/, `height="${height}"`)
      if (fill)
        svg = svg.replace(/fill=\"[#A-Za-z0-9]*\"/, `fill="${fill}"`)
      return svg
    },
    /**
     * Encodes a svg expression into a {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs|data URI}
     * suitable for the `src` property of `img` elements, optionally changing its original size and fill values.
     * @param {string} svg - The SVG image as XML string
     * @param {string=} width - Optional setting for "width" property
     * @param {string=} height - Optional setting for "height" property
     * @param {string=} fill - Optional setting for "fill" property
     * @returns {string} - The resulting Data URI
     */
    svgToURI: (svg, width, height, fill) => 'data:image/svg+xml;base64,' + btoa(Utils.getSvg(svg, width, height, fill)),
    /**
     * Converts the given expression into a valid value for CSS size values
     * @param {string|number} exp - The expression to be evaluated (can be a valid value, `null` or `undefined`)
     * @param {Object} css - An optional Object where the resulting expression (if any) will be saved
     * @param {string} key - The key under which the result will be stored in `css`
     * @param {string} def - Default value to be used when `exp` is `null` or `undefined`
     * @returns {string} - A valid CSS value, or `null` if it can't be found. Default units are `px`
     */
    toCssSize: (exp, css, key, def) => {
      const result = typeof exp === 'undefined' || exp === null ? null : isNaN(exp) ? exp : `${exp}px`
      if (css &amp;&amp; key &amp;&amp; (result || def))
        css[key] = result !== null ? result : def
      return result
    },
    /**
     * Gets a clip of the give image data, in a URL base64 encoded format
     * @param {object} img - The binary data of the realized image, usually obtained from a {@link MediaBagElement}
     * @param {AWT.Rectangle} rect - A rectangle containing the requested clip
     * @returns {string} - The URL with the image clip, as a PNG file encoded in base64
     */
    getImgClipUrl: (img, rect) => {
      const canvas = document.createElement('canvas')
      canvas.width = rect.dim.width
      canvas.height = rect.dim.height
      const ctx = canvas.getContext('2d')
      ctx.drawImage(img, rect.pos.x, rect.pos.y, rect.dim.width, rect.dim.height, 0, 0, rect.dim.width, rect.dim.height)
      return canvas.toDataURL()
    },
    /**
     * Finds the nearest `head` or root node of a given HTMLElement, useful to place `&lt;style/>` elements when
     * the main component of JClic is behind a shadow-root.
     * This method will be replaced by a call to [Node.getRootNode()](https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode)
     * when fully supported by all major browsers.
     * @param {Node=} el - The element from which to start the search
     * @returns {Node}
     */
    getRootHead: el => {
      if (el) {
        // Skip HTMLElements
        while (el.parentElement)
          el = el.parentElement
        // Get the parent node of the last HTMLElement
        if (el instanceof HTMLElement)
          el = el.parentNode || el
        // If the root node has a `head`, take it
        el = el['head'] || el
      }
      return el || document.head
    },
    /**
     * Appends a stylesheet element to the `head` or root node nearest to the given `HTMLElement`.
     * @param {String} css - The content of the stylesheet
     * @param {PlayStation=} ps - An optional `PlayStation` (currently a {@link JClicPlayer}) used as a base to find the root node
     * @returns {HTMLStyleElement} - The appended style element
     */
    appendStyleAtHead: (css, ps) => {
      const root = Utils.getRootHead(ps &amp;&amp; ps.$topDiv ? ps.$topDiv[0] : null)
      const style = document.createElement('style')
      style.type = 'text/css'
      style.appendChild(document.createTextNode(css))
      return root.appendChild(style)
    },
    /**
     * Traverses all the attributes defined in an Element, calling a function with its name and value as a parameters
     * @param {external:NamedNodeMap} attributes - The [Element.attributes](https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes)
     * object to be traversed
     * @param {function} callback - The function to be called for each [Attr](https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap)
     * object. It should take two parametres: `name` and `value`
     */
    attrForEach(attributes, callback) {
      for (let i = 0; i &lt; attributes.length; i++)
        callback(attributes[i].name, attributes[i].value)
    },
    /**
     * Global constants
     * @const
     */
    settings: {
      // layout constants
      AB: 0, BA: 1, AUB: 2, BUA: 3,
      LAYOUT_NAMES: ['AB', 'BA', 'AUB', 'BUA'],
      DEFAULT_WIDTH: 400,
      DEFAULT_HEIGHT: 300,
      MINIMUM_WIDTH: 40,
      MINIMUM_HEIGHT: 40,
      DEFAULT_NAME: '---',
      DEFAULT_MARGIN: 8,
      DEFAULT_SHUFFLES: 31,
      DEFAULT_GRID_ELEMENT_SIZE: 20,
      MIN_CELL_SIZE: 10,
      //DEFAULT_BG_COLOR: '#D3D3D3', // LightGray
      DEFAULT_BG_COLOR: '#C0C0C0', // LightGray
      ACTIONS: {
        ACTION_MATCH: 'MATCH', ACTION_PLACE: 'PLACE',
        ACTION_WRITE: 'WRITE', ACTION_SELECT: 'SELECT', ACTION_HELP: 'HELP'
      },
      PREVIOUS: 0, MAIN: 1, END: 2, END_ERROR: 3, NUM_MSG: 4,
      MSG_TYPE: ['previous', 'initial', 'final', 'finalError'],
      RANDOM_CHARS: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      NUM_COUNTERS: 3,
      MAX_RECORD_LENGTH: 20,
      // BoxBase defaults
      BoxBase: {
        REDUCE_FONT_STEP: 1.0,
        MIN_FONT_SIZE: 8,
        STROKE: 1,
        AC_MARGIN: 6,
        //BACK_COLOR: 'lightgray',
        BACK_COLOR: '#C0C0C0',
        TEXT_COLOR: 'black',
        SHADOW_COLOR: 'gray',
        INACTIVE_COLOR: 'gray',
        ALTERNATIVE_COLOR: 'gray',
        BORDER_COLOR: 'black',
        BORDER_STROKE_WIDTH: 0.75,
        MARKER_STROKE_WIDTH: 2.75
      },
      FILE_TYPES: {
        image: 'gif,jpg,png,jpeg,bmp,ico,svg',
        audio: 'wav,mp3,ogg,oga,au,aiff,flac',
        video: 'avi,mov,mpeg,mp4,ogv,m4v,webm',
        font: 'ttf,otf,eot,woff,woff2',
        midi: 'mid,midi',
        anim: 'swf',
        // Used in custom skins
        xml: 'xml'
      },
      MIME_TYPES: {
        xml: 'text/xml',
        gif: 'image/gif',
        jpg: 'image/jpeg',
        jpeg: 'image/jpeg',
        png: 'image/png',
        bmp: 'image/bmp',
        svg: 'image/svg+xml',
        ico: 'image/x-icon',
        wav: 'audio/wav',
        mp3: 'audio/mpeg',
        mp4: 'video/mp4',
        m4v: 'video/mp4',
        ogg: 'audio/ogg',
        oga: 'audio/ogg',
        ogv: 'video/ogg',
        webm: 'video/webm',
        au: 'audio/basic',
        aiff: 'audio/x-aiff',
        flac: 'audio/flac',
        avi: 'video/avi',
        mov: 'video/quicktime',
        mpeg: 'video/mpeg',
        ttf: 'application/font-sfnt',
        otf: 'application/font-sfnt',
        eot: ' application/vnd.ms-fontobject',
        woff: 'application/font-woff',
        woff2: 'application/font-woff2',
        swf: 'application/x-shockwave-flash'
      },
      // Global settings susceptible to be modified
      COMPRESS_IMAGES: true,
      // Keyboard key codes
      VK: {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40
      },
      // Flag to indicate that we are running on a touch device
      TOUCH_DEVICE: false,
      // Amount of time (in milliseconds) to wait before a media resource is loaded
      LOAD_TIMEOUT: 10000,
      // Number of points to be calculated as polygon vertexs when simplifying bezier curves
      BEZIER_POINTS: 4,
      // Check if canvas accessibility features are enabled
      // See: http://codepen.io/francesc/pen/amwvRp
      CANVAS_HITREGIONS: typeof CanvasRenderingContext2D !== 'undefined' &amp;&amp; typeof CanvasRenderingContext2D.prototype.addHitRegion === 'function',
      CANVAS_HITREGIONS_FOCUS: typeof CanvasRenderingContext2D !== 'undefined' &amp;&amp; typeof CanvasRenderingContext2D.prototype.drawFocusIfNeeded === 'function'
    },
    //
    // Functions useful to deal with caret position in `contentEditable` DOM elements
    //
    /**
     * Gets the caret position within the given element. Thanks to
     * {@link http://stackoverflow.com/users/96100/tim-down|Tim Down} answers in:
     * {@link http://stackoverflow.com/questions/4811822/get-a-ranges-start-and-end-offsets-relative-to-its-parent-container}
     * and {@link http://stackoverflow.com/questions/6240139/highlight-text-range-using-javascript/6242538}
     * @param {object} element - A DOM element
     * @returns {number}
     */
    getCaretCharacterOffsetWithin: element => {
      let caretOffset = 0
      const doc = element.ownerDocument || element.document
      const win = doc.defaultView || doc.parentWindow
      let sel
      if (typeof win.getSelection !== "undefined") {
        sel = win.getSelection()
        if (sel.rangeCount > 0) {
          const range = win.getSelection().getRangeAt(0)
          const preCaretRange = range.cloneRange()
          preCaretRange.selectNodeContents(element)
          preCaretRange.setEnd(range.endContainer, range.endOffset)
          caretOffset = preCaretRange.toString().length
        }
      } else if ((sel = doc.selection) &amp;&amp; sel.type !== "Control") {
        const textRange = sel.createRange()
        const preCaretTextRange = doc.body.createTextRange()
        preCaretTextRange.moveToElementText(element)
        preCaretTextRange.setEndPoint("EndToEnd", textRange)
        caretOffset = preCaretTextRange.text.length
      }
      return caretOffset
    },
    /**
     * Utility function called by {@link Utils~getCaretCharacterOffsetWithin}
     * @param {object} node - A text node
     * @returns {object[]}
     */
    getTextNodesIn: function (node) {
      const textNodes = []
      if (node.nodeType === 3) {
        textNodes.push(node)
      } else {
        const children = node.childNodes
        for (let i = 0, len = children.length; i &lt; len; ++i) {
          textNodes.push.apply(textNodes, Utils.getTextNodesIn(children[i]))
        }
      }
      return textNodes
    },
    /**
     * Sets the selection range (or the cursor position, when `start` and `end` are the same) to a
     * specific position inside a DOM element.
     * @param {object} el - The DOM element where to set the cursor
     * @param {number} start - The start position of the selection (or cursor position)
     * @param {type} end - The end position of the selection. When null or identical to `start`,
     * indicates a cursor position.
     */
    setSelectionRange: (el, start, end) => {
      if (Utils.isNullOrUndef(end))
        end = start
      if (document.createRange &amp;&amp; window.getSelection) {
        const range = document.createRange()
        range.selectNodeContents(el)
        const textNodes = Utils.getTextNodesIn(el)
        let foundStart = false
        let charCount = 0, endCharCount, textNode

        for (let i = 0; i &lt; textNodes.length; i++) {
          textNode = textNodes[i]
          endCharCount = charCount + textNode.length
          if (!foundStart &amp;&amp; start >= charCount &amp;&amp;
            (start &lt; endCharCount ||
              start === endCharCount &amp;&amp; i + 1 &lt;= textNodes.length)) {
            range.setStart(textNode, start - charCount)
            foundStart = true
          }
          if (foundStart &amp;&amp; end &lt;= endCharCount) {
            range.setEnd(textNode, end - charCount)
            break
          }
          charCount = endCharCount
        }
        const sel = window.getSelection()
        sel.removeAllRanges()
        sel.addRange(range)
      } else if (document.selection &amp;&amp; document.body.createTextRange) {
        const textRange = document.body.createTextRange()
        textRange.moveToElementText(el)
        textRange.collapse(true)
        textRange.moveEnd('character', end)
        textRange.moveStart('character', start)
        textRange.select()
      }
    }
  }

  return Utils
})
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
