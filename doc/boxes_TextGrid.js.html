<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>JClic.js Source: boxes/TextGrid.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.united.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">JClic.js</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-JClic.html">JClic</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="AbstractBox.html">AbstractBox</a></li><li><a href="Action.html">Action</a></li><li><a href="ActionReg.html">ActionReg</a></li><li><a href="ActiveBagContent.html">ActiveBagContent</a></li><li><a href="ActiveBox.html">ActiveBox</a></li><li><a href="ActiveBoxBag.html">ActiveBoxBag</a></li><li><a href="ActiveBoxContent.html">ActiveBoxContent</a></li><li><a href="ActiveBoxGrid.html">ActiveBoxGrid</a></li><li><a href="ActiveMediaBag.html">ActiveMediaBag</a></li><li><a href="ActiveMediaPlayer.html">ActiveMediaPlayer</a></li><li><a href="Activity.html">Activity</a></li><li><a href="ActivityPanel.html">ActivityPanel</a></li><li><a href="ActivityReg.html">ActivityReg</a></li><li><a href="ActivitySequence.html">ActivitySequence</a></li><li><a href="ActivitySequenceElement.html">ActivitySequenceElement</a></li><li><a href="ActivitySequenceJump.html">ActivitySequenceJump</a></li><li><a href="Arith.html">Arith</a></li><li><a href="Arith.Operator.html">Arith.Operator</a></li><li><a href="AudioBuffer.html">AudioBuffer</a></li><li><a href="AutoContentProvider.html">AutoContentProvider</a></li><li><a href="AutoContentProvider.ActiveBagContentKit.html">AutoContentProvider.ActiveBagContentKit</a></li><li><a href="BasicEvaluator.html">BasicEvaluator</a></li><li><a href="BlueSkin.html">BlueSkin</a></li><li><a href="BoxBag.html">BoxBag</a></li><li><a href="BoxBase.html">BoxBase</a></li><li><a href="BoxConnector.html">BoxConnector</a></li><li><a href="ClassicJigSaw.html">ClassicJigSaw</a></li><li><a href="Complete.html">Complete</a></li><li><a href="CompletePanel.html">CompletePanel</a></li><li><a href="ComplexAssociation.html">ComplexAssociation</a></li><li><a href="ComplexAssociationPanel.html">ComplexAssociationPanel</a></li><li><a href="ComplexEvaluator.html">ComplexEvaluator</a></li><li><a href="ConditionalJumpInfo.html">ConditionalJumpInfo</a></li><li><a href="Container.html">Container</a></li><li><a href="Counter.html">Counter</a></li><li><a href="CrossWord.html">CrossWord</a></li><li><a href="CrossWordPanel.html">CrossWordPanel</a></li><li><a href="CustomSkin.html">CustomSkin</a></li><li><a href="DefaultSkin.html">DefaultSkin</a></li><li><a href="Dimension.html">Dimension</a></li><li><a href="DoublePuzzle.html">DoublePuzzle</a></li><li><a href="DoublePuzzlePanel.html">DoublePuzzlePanel</a></li><li><a href="Ellipse.html">Ellipse</a></li><li><a href="EmptySkin.html">EmptySkin</a></li><li><a href="Encryption.html">Encryption</a></li><li><a href="Evaluator.html">Evaluator</a></li><li><a href="EventSounds.html">EventSounds</a></li><li><a href="EventSoundsElement.html">EventSoundsElement</a></li><li><a href="ExchangePuzzle.html">ExchangePuzzle</a></li><li><a href="ExchangePuzzlePanel.html">ExchangePuzzlePanel</a></li><li><a href="Explore.html">Explore</a></li><li><a href="ExplorePanel.html">ExplorePanel</a></li><li><a href="FillInBlanks.html">FillInBlanks</a></li><li><a href="FillInBlanksPanel.html">FillInBlanksPanel</a></li><li><a href="Font.html">Font</a></li><li><a href="Gradient.html">Gradient</a></li><li><a href="GreenSkin.html">GreenSkin</a></li><li><a href="HolePuzzle.html">HolePuzzle</a></li><li><a href="HolePuzzlePanel.html">HolePuzzlePanel</a></li><li><a href="Holes.html">Holes</a></li><li><a href="Identify.html">Identify</a></li><li><a href="IdentifyPanel.html">IdentifyPanel</a></li><li><a href="IdentifyText.html">IdentifyText</a></li><li><a href="IdentifyTextPanel.html">IdentifyTextPanel</a></li><li><a href="InformationScreen.html">InformationScreen</a></li><li><a href="InformationScreenPanel.html">InformationScreenPanel</a></li><li><a href="JClicPlayer.html">JClicPlayer</a></li><li><a href="JClicProject.html">JClicProject</a></li><li><a href="JigSaw.html">JigSaw</a></li><li><a href="JumpInfo.html">JumpInfo</a></li><li><a href="MediaBag.html">MediaBag</a></li><li><a href="MediaBagElement.html">MediaBagElement</a></li><li><a href="MediaContent.html">MediaContent</a></li><li><a href="MemoryGame.html">MemoryGame</a></li><li><a href="MemoryGamePanel.html">MemoryGamePanel</a></li><li><a href="Menu.html">Menu</a></li><li><a href="MenuPanel.html">MenuPanel</a></li><li><a href="MiniSkin.html">MiniSkin</a></li><li><a href="OrangeSkin.html">OrangeSkin</a></li><li><a href="OrderText.html">OrderText</a></li><li><a href="OrderTextPanel.html">OrderTextPanel</a></li><li><a href="Path.html">Path</a></li><li><a href="PathStroke.html">PathStroke</a></li><li><a href="PlayerHistory.html">PlayerHistory</a></li><li><a href="PlayerHistory_HistoryElement.html">PlayerHistory#HistoryElement</a></li><li><a href="Point.html">Point</a></li><li><a href="ProjectSettings.html">ProjectSettings</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="Rectangular.html">Rectangular</a></li><li><a href="ReportBean.html">ReportBean</a></li><li><a href="Reporter.html">Reporter</a></li><li><a href="ReporterInfo.html">ReporterInfo</a></li><li><a href="SCORM.html">SCORM</a></li><li><a href="SequenceReg.html">SequenceReg</a></li><li><a href="SequenceRegInfo.html">SequenceRegInfo</a></li><li><a href="SessionReg.html">SessionReg</a></li><li><a href="SessionRegInfo.html">SessionRegInfo</a></li><li><a href="SessionStorageReporter.html">SessionStorageReporter</a></li><li><a href="Shape.html">Shape</a></li><li><a href="Shaper.html">Shaper</a></li><li><a href="SimpleAssociation.html">SimpleAssociation</a></li><li><a href="SimpleAssociationPanel.html">SimpleAssociationPanel</a></li><li><a href="SimpleSkin.html">SimpleSkin</a></li><li><a href="Skin.html">Skin</a></li><li><a href="Stroke.html">Stroke</a></li><li><a href="TCPReporter.html">TCPReporter</a></li><li><a href="TextActivityBase.html">TextActivityBase</a></li><li><a href="TextActivityBasePanel.html">TextActivityBasePanel</a></li><li><a href="TextActivityDocument.html">TextActivityDocument</a></li><li><a href="TextGrid.html">TextGrid</a></li><li><a href="TextGridContent.html">TextGridContent</a></li><li><a href="TextTarget.html">TextTarget</a></li><li><a href="Timer.html">Timer</a></li><li><a href="TriangularJigSaw.html">TriangularJigSaw</a></li><li><a href="Utils.html">Utils</a></li><li><a href="WordSearch.html">WordSearch</a></li><li><a href="WordSearchPanel.html">WordSearchPanel</a></li><li><a href="WrittenAnswer.html">WrittenAnswer</a></li><li><a href="WrittenAnswerPanel.html">WrittenAnswerPanel</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="externals.list.html" class="dropdown-toggle" data-toggle="dropdown">Externals<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="external-CanvasRenderingContext2D.html">CanvasRenderingContext2D</a></li><li><a href="external-Collator.html">Collator</a></li><li><a href="external-HTMLAudioElement.html">HTMLAudioElement</a></li><li><a href="external-HTMLElement.html">HTMLElement</a></li><li><a href="external-HTMLImageElement.html">HTMLImageElement</a></li><li><a href="external-i18next.html">i18next</a></li><li><a href="external-jQuery.html">jQuery</a></li><li><a href="external-jqXHR.html">jqXHR</a></li><li><a href="external-JSZip.html">JSZip</a></li><li><a href="external-MediaRecorder.html">MediaRecorder</a></li><li><a href="external-NamedNodeMap.html">NamedNodeMap</a></li><li><a href="external-Promise.html">Promise</a></li><li><a href="external-Storage.html">Storage</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: boxes/TextGrid.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/**
 *  File    : boxes/TextGrid.js
 *  Created : 12/06/2015
 *  By      : Francesc Busquets &lt;francesc@gmail.com>
 *
 *  JClic.js
 *  An HTML5 player of JClic activities
 *  https://projectestac.github.io/jclic.js
 *
 *  @source https://github.com/projectestac/jclic.js
 *
 *  @license EUPL-1.1
 *  @licstart
 *  (c) 2000-2018 Catalan Educational Telematic Network (XTEC)
 *
 *  Licensed under the EUPL, Version 1.1 or -as soon they will be approved by
 *  the European Commission- subsequent versions of the EUPL (the "Licence");
 *  You may not use this work except in compliance with the Licence.
 *
 *  You may obtain a copy of the Licence at:
 *  https://joinup.ec.europa.eu/software/page/eupl
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  Licence for the specific language governing permissions and limitations
 *  under the Licence.
 *  @licend
 */

/* global define */

define([
  "jquery",
  "../AWT",
  "../Utils",
  "./AbstractBox",
  "./TextGridContent"
], function ($, AWT, Utils, AbstractBox, TextGridContent) {

  /**
   * Default values
   * @type {object} */
  const defaults = {
    MIN_CELL_SIZE: 12,
    DEFAULT_CELL_SIZE: 20,
    MIN_INTERNAL_MARGIN: 2
  }

  /**
   * Binary flags used to mark status
   * @type {object} */
  const flags = {
    NORMAL: 0,
    INVERTED: 1,
    HIDDEN: 2,
    LOCKED: 4,
    MARKED: 8,
    TRANSPARENT: 16
  }

  /**
   * This class is a special type of {@link AbstractBox} that displays a grid of single
   * characters.
   *
   * It's used {@link CrossWord} and {@link WordSearch} activities.
   * @exports TextGrid
   * @class
   * @extends AbstractBox
   */
  class TextGrid extends AbstractBox {
    /**
     * TextGrid constructor
     * @param {?AbstractBox} parent - The AbstractBox to which this text grid belongs
     * @param {?AWT.Container} container - The container where this text grid is placed.
     * @param {?BoxBase} boxBase - The object where colors, fonts, border and other graphic properties
     * @param {number} x - `X` coordinate of the upper left corner of this grid
     * @param {number} y - `Y` coordinate of the upper left corner of this grid
     * @param {number} ncw - Number of columns of the grid
     * @param {number} nch - Nomber of rows of the grid
     * @param {number} cellW - Width of the cells
     * @param {number} cellH - Height of the cells
     * @param {boolean} border - When `true`, a border must be drawn between the cells
     */
    constructor(parent, container, boxBase, x, y, ncw, nch, cellW, cellH, border) {
      // *TextGrid* extends [AbstractBox](AbstractBox.html)
      super(parent, container, boxBase)
      this.pos.x = x
      this.pos.y = y
      this.nCols = Math.max(1, ncw)
      this.nRows = Math.max(1, nch)
      this.cellWidth = Math.max(cellW, defaults.MIN_CELL_SIZE)
      this.cellHeight = Math.max(cellH, defaults.MIN_CELL_SIZE)
      this.dim.width = cellW * this.nCols
      this.dim.height = cellH * this.nRows
      this.setChars(' ')
      this.preferredBounds = new AWT.Rectangle(this.pos, this.dim)
      this.setBorder(border)
      this.cursorTimer = new AWT.Timer(() => this.blink(0), 500, false)
      this.cursorEnabled = false
      this.useCursor = false
      this.wildTransparent = false
      this.cursor = new AWT.Point()
    }

    /**
     * Factory constructor that creates an empty grid based on a {@link TextGridContent}
     * @param {?AbstractBox} parent - The AbstractBox to which the text grid belongs
     * @param {?AWT.Container} container - The container where the text grid will be placed.
     * @param {number} x - `X` coordinate of the upper left corner of the grid
     * @param {number} y - `Y` coordinate of the upper left corner of the grid
     * @param {TextGridContent} tgc - Object with the content and other settings of the grid
     * @param {boolean} wildTransparent - When `true`, the wildcard character will be transparent
     * @returns {TextGrid}
     */
    static createEmptyGrid(parent, container, x, y, tgc, wildTransparent) {
      const result = new TextGrid(parent, container, tgc.bb,
        x, y, tgc.ncw, tgc.nch, tgc.w, tgc.h, tgc.border)
      result.wild = tgc.wild
      result.randomChars = tgc.randomChars
      result.wildTransparent = wildTransparent
      return result
    }

    /**
     * Sets the characters to be placed in the cells of this TextGrid
     * @param {string} text
     */
    setChars(text) {
      this.chars = []
      this.answers = []
      this.attributes = []
      for (let py = 0; py &lt; this.nRows; py++) {
        const line = py &lt; text.length ? text[py] : ''
        this.chars[py] = line.split('')
        this.answers[py] = []
        this.attributes[py] = []
        for (let px = 0; px &lt; this.nCols; px++) {
          if (px >= line.length)
            this.chars[py][px] = ' '
          this.answers[py][px] = this.chars[py][px]
          this.attributes[py][px] = flags.NORMAL
        }
      }
    }

    /**
     * Substitutes the current content of all cells with wildcards with a randomly generated char.
     * @see TextGridContent#randomChars
     */
    randomize() {
      for (let py = 0; py &lt; this.nRows; py++)
        for (let px = 0; px &lt; this.nCols; px++)
          if (this.chars[py][px] === this.wild)
            this.chars[py][px] = this.randomChars.charAt(
              Math.floor(Math.random() * this.randomChars.length))
    }

    /**
     * Clears or sets global attributes to all cells
     * @param {boolean} lockWild - When `true`, the wildcard cells will be marked with special
     * attributes (used in CrossWords to mark black cells)
     * @param {boolean} clearChars - When `true`, the current content of cells will be erased.
     */
    setCellAttributes(lockWild, clearChars) {
      let atr = flags.LOCKED
      if (this.wildTransparent)
        atr |= flags.TRANSPARENT
      else
        atr |= flags.INVERTED | flags.HIDDEN
      for (let py = 0; py &lt; this.nRows; py++) {
        for (let px = 0; px &lt; this.nCols; px++) {
          if (lockWild &amp;&amp; this.chars[py][px] === this.wild)
            this.attributes[py][px] = atr
          else {
            this.attributes[py][px] = flags.NORMAL
            if (clearChars)
              this.chars[py][px] = ' '
          }
        }
      }
    }

    /**
     * Sets or unsets the `locked` properties (black cell) to a specific cell.
     * @param {number} px - The logical 'X' coordinate of the cell
     * @param {number} py - The logical 'Y' coordinate of the cell
     * @param {boolean} locked - When true, the `locked` attribute will be on.
     * @returns {undefined}
     */
    setCellLocked(px, py, locked) {
      if (px >= 0 &amp;&amp; px &lt; this.nCols &amp;&amp; py >= 0 &amp;&amp; py &lt; this.nRows) {
        this.attributes[py][px] = locked ?
          flags.LOCKED |
          (this.wildTransparent ?
            flags.TRANSPARENT :
            flags.INVERTED |
            flags.HIDDEN) :
          flags.NORMAL
      }
    }

    /**
     * For a specific cell located at column `rx` and row `ry`, finds the number of words delimited
     * by wildchars located behind its current position and in the same row and column. Used in
     * {@link CrossWord} activities to find the definition for a specific cell.
     *
     * The result is returned as 'x' and 'y' properties of a logical point.
     * @param {type} rx - The 'X' position of the cell
     * @param {type} ry - The 'Y' position of the cell
     * @returns {AWT.Point} - The logical positions of the definition for this cell inside the list
     * of current definitions of its row and column. '0' means first definition of its row/column,
     * '1' the second one, etc.
     */
    getItemFor(rx, ry) {
      if (!this.isValidCell(rx, ry))
        return null

      const point = new AWT.Point()
      let
        inBlack = false,
        startCount = false

      for (let px = 0; px &lt; rx; px++) {
        if ((this.attributes[ry][px] &amp; flags.LOCKED) !== 0) {
          if (!inBlack) {
            if (startCount)
              point.x++
            inBlack = true
          }
        } else {
          startCount = true
          inBlack = false
        }
      }
      inBlack = false
      startCount = false
      for (let py = 0; py &lt; ry; py++) {
        if ((this.attributes[py][rx] &amp; flags.LOCKED) !== 0) {
          if (!inBlack) {
            if (startCount)
              point.y++
            inBlack = true
          }
        } else {
          startCount = true
          inBlack = false
        }
      }
      return point
    }

    /**
     * Whether the blinking cursor must be enabled or disabled.
     * @param {boolean} status
     */
    setCursorEnabled(status) {
      this.cursorEnabled = status
      if (status === true)
        this.startCursorBlink()
      else
        this.stopCursorBlink()
    }

    /**
     * Starts the {@link AWT.Timer} that makes the cursor blink.
     */
    startCursorBlink() {
      if (this.useCursor &amp;&amp; this.cursorEnabled &amp;&amp; this.cursorTimer &amp;&amp; !this.cursorTimer.isRunning()) {
        this.blink(1)
        this.cursorTimer.start()
      }
    }

    /**
     * Stops the {@link AWT.Timer} that makes the cursor blink.
     */
    stopCursorBlink() {
      if (this.cursorTimer &amp;&amp; this.cursorTimer.isRunning()) {
        this.cursorTimer.stop()
        this.blink(-1)
      }
    }

    /**
     * Moves the cursor in the specified x and y directions.
     * @param {number} dx - Amount to move in the 'X' axis
     * @param {number} dy - Amount to move in the 'Y' axis
     * @param {boolean} skipLocked - Skip locked cells (wildcards in {@link CrossWord})
     */
    moveCursor(dx, dy, skipLocked) {
      if (this.useCursor) {
        const point = this.findNextCellWithAttr(this.cursor.x, this.cursor.y,
          skipLocked ? flags.LOCKED : flags.NORMAL,
          dx, dy, false)

        if (!this.cursor.equals(point))
          this.setCursorAt(point.x, point.y, skipLocked)
      }
    }

    /**
     * Finds the coordinates of the nearest non-locked cell (non-wildcard) moving on the indicated
     * 'X' and 'Y' directions.
     * @param {AWT.Point} - Logical coordinates of the starting point
     * @param {number} dx - 0 means no movement, 1 go right, -1 go left.
     * @param {number} dy - 0 means no movement, 1 go down, -1 go up.
     * @returns {AWT.Point}
     */
    findFreeCell(from, dx, dy) {
      let result = null
      if (from &amp;&amp; (dx !== 0 || dy !== 0)) {
        const scan = new AWT.Point(from)
        while (result === null) {
          scan.x += dx
          scan.y += dy
          if (scan.x &lt; 0 || scan.x >= this.nCols || scan.y &lt; 0 || scan.y >= this.nRows)
            break
          if (!this.getCellAttribute(scan.x, scan.y, flags.LOCKED))
            result = scan
        }
      }
      return result
    }

    /**
     * Finds the first cell with the specified attributes at the specified state, starting
     * at specified point.
     * @param {number} startX - Starting X coordinate
     * @param {number} startY - Starting Y coordinate
     * @param {number} attr - Attribute to check. See {@link TextGrid.flags}.
     * @param {number} dx - 0 means no movement, 1 go right, -1 go left.
     * @param {number} dy - 0 means no movement, 1 go down, -1 go up.
     * @param {boolean} attrState - Desired state (enabled or disabled) of `attr`
     * @returns {AWT.Point}
     */
    findNextCellWithAttr(startX, startY, attr, dx, dy, attrState) {
      const point = new AWT.Point(startX + dx, startY + dy)
      while (true) {
        if (point.x &lt; 0) {
          point.x = this.nCols - 1
          if (point.y > 0)
            point.y--
          else
            point.y = this.nRows - 1
        } else if (point.x >= this.nCols) {
          point.x = 0
          if (point.y &lt; this.nRows - 1)
            point.y++
          else
            point.y = 0
        }
        if (point.y &lt; 0) {
          point.y = this.nRows - 1
          if (point.x > 0)
            point.x--
          else
            point.x = this.nCols - 1
        } else if (point.y >= this.nRows) {
          point.y = 0
          if (point.x &lt; this.nCols - 1)
            point.x++
          else
            point.x = 0
        }
        if (point.x === startX &amp;&amp; point.y === startY ||
          this.getCellAttribute(point.x, point.y, attr) === attrState)
          break
        point.x += dx
        point.y += dy
      }
      return point
    }

    /**
     * Sets the blinking cursor at a specific point
     * @param {number} px - X coordinate
     * @param {number} py - Y coordinate
     * @param {boolean} skipLocked - Skip locked (wildcard) cells
     */
    setCursorAt(px, py, skipLocked) {
      this.stopCursorBlink()
      if (this.isValidCell(px, py)) {
        this.cursor.x = px
        this.cursor.y = py
        this.useCursor = true
        if (skipLocked &amp;&amp; this.getCellAttribute(px, py, flags.LOCKED)) {
          this.moveCursor(1, 0, skipLocked)
        } else {
          if (this.cursorEnabled)
            this.startCursorBlink()
        }
      }
    }

    /**
     * Sets the `useCursor` property of this text grid
     * @param {boolean} value
     */
    setUseCursor(value) {
      this.useCursor = value
    }

    /**
     * Gets the current position of the blinking cursor
     * @returns {AWT.Point}
     */
    getCursor() {
      return this.cursor
    }

    /**
     * Counts the number of cells of this grid with the specified character
     * @param {string} ch
     * @returns {number}
     */
    countCharsLike(ch) {
      let result = 0
      for (let py = 0; py &lt; this.nRows; py++)
        for (let px = 0; px &lt; this.nCols; px++)
          if (this.chars[py][px] === ch)
            result++
      return result
    }

    /**
     * Gets the number of cells of this grid
     * @returns {number}
     */
    getNumCells() {
      return this.nRows * this.nCols
    }

    /**
     * Counts the number of coincidences between the `answers` array and the current content of this grid
     * @param {boolean} checkCase - Make comparisions case-sensitive
     * @returns {number}
     */
    countCoincidences(checkCase) {
      let result = 0
      if (this.answers)
        for (let py = 0; py &lt; this.nRows; py++)
          for (let px = 0; px &lt; this.nCols; px++)
            if (this.isCellOk(px, py, checkCase))
              result++
      return result
    }

    /**
     * Checks if a specific cell is equivalent to the content of `answers` at its position
     * @param {number} px - X coordinate
     * @param {number} py - Y coordinate
     * @param {boolean} checkCase - Make comparisions case-sensitive
     * @returns {boolean}
     */
    isCellOk(px, py, checkCase) {
      let result = false
      if (this.isValidCell(px, py)) {
        const ch = this.chars[py][px]
        if (ch !== this.wild) {
          const ch2 = this.answers[py][px]
          if (ch === ch2 ||
            !checkCase &amp;&amp; ch.toUpperCase() === ch2.toUpperCase())
            result = true
        }
      }
      return result
    }

    /**
     * Gets the logical coordinates (in 'cell' units) of a device point into the grid
     * @param {AWT.Point} devicePoint
     * @returns {AWT.Point}
     */
    getLogicalCoords(devicePoint) {
      if (!this.contains(devicePoint))
        return null
      const
        px = Math.floor((devicePoint.x - this.pos.x) / this.cellWidth),
        py = Math.floor((devicePoint.y - this.pos.y) / this.cellHeight)

      return this.isValidCell(px, py) ? new AWT.Point(px, py) : null
    }

    /**
     * Checks if the specified logical coordinates are inside the valid bounds of the grid.
     * @param {number} px - 'X' coordinate
     * @param {number} py - 'Y' coordinate
     * @returns {boolean}
     */
    isValidCell(px, py) {
      return px &lt; this.nCols &amp;&amp; py &lt; this.nRows &amp;&amp; px >= 0 &amp;&amp; py >= 0
    }

    /**
     * Sets the specified character as a content of the cell at specified coordinates
     * @param {number} px - 'X' coordinate
     * @param {number} py - 'Y' coordinate
     * @param {string} ch - The character to set.
     */
    setCharAt(px, py, ch) {
      if (this.isValidCell(px, py)) {
        this.chars[py][px] = ch
        this.repaintCell(px, py)
      }
    }

    /**
     * Gets the character of the cell at the specified coordinates
     * @param {number} px - 'X' coordinate
     * @param {number} py - 'Y' coordinate
     * @returns {string}
     */
    getCharAt(px, py) {
      return this.isValidCell(px, py) ? this.chars[py][px] : ' '
    }

    /**
     * Gets the text formed by the letters between two cells that share a straight line on the grid.
     * The text can be formed horizontally, vertically and diagonal, both in left-to-right or
     * right-to-left direction.
     * @param {number} x0 - 'X' coordinate of the first cell
     * @param {number} y0 - 'Y' coordinate of the first cell
     * @param {number} x1 - 'X' coordinate of the second cell
     * @param {number} y1 - 'Y' coordinate of the second cell
     * @returns {string}
     */
    getStringBetween(x0, y0, x1, y1) {
      let sb = ''
      if (this.isValidCell(x0, y0) &amp;&amp; this.isValidCell(x1, y1)) {
        let
          dx = x1 - x0,
          dy = y1 - y0
        if (dx === 0 || dy === 0 || Math.abs(dx) === Math.abs(dy)) {
          const steps = Math.max(Math.abs(dx), Math.abs(dy))
          if (steps > 0) {
            dx /= steps
            dy /= steps
          }
          for (let i = 0; i &lt;= steps; i++)
            sb += this.getCharAt(x0 + dx * i, y0 + dy * i)
        }
      }
      return sb
    }

    /**
     * Sets a specific attribute to all cells forming a straight line between two cells on the grid.
     * @param {number} x0 - 'X' coordinate of the first cell
     * @param {number} y0 - 'Y' coordinate of the first cell
     * @param {number} x1 - 'X' coordinate of the second cell
     * @param {number} y1 - 'Y' coordinate of the second cell
     * @param {number} attribute - The binary flag representing this attribute. See {@link TextGrid.flags}.
     * @param {boolean} value - Whether to set or unset the attribute.
     */
    setAttributeBetween(x0, y0, x1, y1, attribute, value) {
      if (this.isValidCell(x0, y0) &amp;&amp; this.isValidCell(x1, y1)) {
        let
          dx = x1 - x0,
          dy = y1 - y0

        if (dx === 0 || dy === 0 || Math.abs(dx) === Math.abs(dy)) {
          const steps = Math.max(Math.abs(dx), Math.abs(dy))
          if (steps > 0) {
            dx /= steps
            dy /= steps
          }
          for (let i = 0; i &lt;= steps; i++)
            this.setAttribute(x0 + dx * i, y0 + dy * i, attribute, value)
        }
      }
    }

    /**
     * Sets or unsets a specifi attrobut to a cell.
     * @param {number} px - The 'X' coordinate of the cell
     * @param {number} py - The 'Y' coordinate of the cell
     * @param {number} attribute - The binary flag representing this attribute. See {@link TextGrid.flags}.
     * @param {boolean} state - Whether to set or unset the attribute.
     */
    setAttribute(px, py, attribute, state) {
      if (this.isValidCell(px, py)) {
        if (this.attribute === flags.MARKED &amp;&amp; !state)
          this.repaintCell(px, py)
        this.attributes[py][px] &amp;= ~attribute
        this.attributes[py][px] |= state ? attribute : 0
        if (attribute !== flags.MARKED || state)
          this.repaintCell(px, py)
      }
    }

    /**
     * Sets the specified attribute to all cells.
     * @param {number} attribute - The binary flag representing this attribute. See {@link TextGrid.flags}.
     * @param {boolean} state - Whether to set or unset the attribute.
     */
    setAllCellsAttribute(attribute, state) {
      for (let py = 0; py &lt; this.nRows; py++)
        for (let px = 0; px &lt; this.nCols; px++)
          this.setAttribute(px, py, attribute, state)
    }

    /**
     * Gets the specified attribute of a cell
     * @param {number} px - The 'X' coordinate of the cell
     * @param {number} py - The 'Y' coordinate of the cell
     * @param {number} attribute - The binary flag representing this attribute. See {@link TextGrid.flags}.
     * @returns {boolean} - `true` if the cell has this attribute, `false` otherwise.
     */
    getCellAttribute(px, py, attribute) {
      return this.isValidCell(px, py) ? (this.attributes[py][px] &amp; attribute) !== 0 : false
    }

    /**
     * Gets the rectangle enclosing a specific cell
     * @param {number} px - The 'X' coordinate of the cell
     * @param {number} py - The 'Y' coordinate of the cell
     * @returns {AWT.Rectangle}
     */
    getCellRect(px, py) {
      return new AWT.Rectangle(this.pos.x + px * this.cellWidth, this.pos.y + py * this.cellHeight, this.cellWidth, this.cellHeight)
    }

    /**
     * Gets the rectangle enclosing a specific cell, including the border thick.
     * @param {number} px - The 'X' coordinate of the cell
     * @param {number} py - The 'Y' coordinate of the cell
     * @returns {AWT.Rectangle}
     */
    getCellBorderBounds(px, py) {
      const isMarked = this.getCellAttribute(px, py, flags.MARKED)
      if (!this.border &amp;&amp; !isMarked)
        return this.getCellRect(px, py)

      const
        bb = this.getBoxBaseResolve(),
        strk = isMarked ? bb.markerStroke : bb.borderStroke

      return this.getCellRect(px, py).grow(strk.lineWidth, strk.lineWidth)
    }

    /**
     * Repaints a cell
     * @param {number} px - The 'X' coordinate of the cell
     * @param {number} py - The 'Y' coordinate of the cell
     */
    repaintCell(px, py) {
      if (this.container)
        this.container.invalidate(this.getCellBorderBounds(px, py)).update()
    }

    /**
     * Gets the preferred size of this grid
     * @returns {AWT.Dimension}
     */
    getPreferredSize() {
      return this.preferredBounds.dim
    }

    /**
     * Gets the minimum size of this grid
     * @returns {AWT.Dimension}
     */
    getMinimumSize() {
      return new AWT.Dimension(defaults.MIN_CELL_SIZE * this.nCols, defaults.MIN_CELL_SIZE * this.nRows)
    }

    /**
     * Scales the grid to a new size
     * @param {number} scale - The factor used to multiply all coordinates and sizes
     * @returns {AWT.Dimension}
     */
    getScaledSize(scale) {
      return new AWT.Dimension(
        Utils.roundTo(scale * this.preferredBounds.dim.width, this.nCols),
        Utils.roundTo(scale * this.preferredBounds.dim.height, this.nRows))
    }

    /**
     * Overrides {@link AbstractBox#setBounds}
     * @override
     * @param {(AWT.Rectangle|number)} rect - An AWT.Rectangle object, or the `x` coordinate of the
     * upper-left corner of a new rectangle.
     * @param {number=} y - `y` coordinate of the upper-left corner of the new rectangle.
     * @param {number=} w - Width of the new rectangle.
     * @param {number=} h - Height of the new rectangle.
     */
    setBounds(rect, y, w, h) {
      super.setBounds(rect, y, w, h)
      this.cellWidth = this.dim.width / this.nCols
      this.cellHeight = this.dim.height / this.nRows
    }

    /**
     * Overrides {@link AbstractBox#updateContent}
     * @override
     * @param {external:CanvasRenderingContext2D} ctx - The canvas rendering context used to draw the
     * grid.
     * @param {AWT.Rectangle=} dirtyRegion - The area that must be repainted. `null` refers to the whole box.
     */
    updateContent(ctx, dirtyRegion) {
      const bb = this.getBoxBaseResolve()

      // test font size
      ctx.font = bb.font.cssFont()
      ctx.textBaseline = 'hanging'
      bb.prepareText(ctx, 'W',
        this.cellWidth - 2 * defaults.MIN_INTERNAL_MARGIN,
        this.cellHeight - 2 * defaults.MIN_INTERNAL_MARGIN)

      const ch = []
      //
      // TODO: Check in different browsers and devices what is the real font height.
      // In Chrome on Linux (Gnome), subtracting `bb.font._metrics.descent / 4` produces
      // good results, but in iPad this correction places the character at the bottom of the cell.
      const ry = (this.cellHeight - bb.font.getHeight()) / 2

      for (let py = 0; py &lt; this.nRows; py++) {
        for (let px = 0; px &lt; this.nCols; px++) {
          const bxr = this.getCellBorderBounds(px, py)
          if (bxr.intersects(dirtyRegion)) {
            const attr = this.attributes[py][px]
            if ((attr &amp; flags.TRANSPARENT) === 0) {
              const isInverted = (attr &amp; flags.INVERTED) !== 0
              const isMarked = (attr &amp; flags.MARKED) !== 0
              const isCursor = this.useCursor &amp;&amp; this.cursor.x === px &amp;&amp; this.cursor.y === py
              const boxBounds = this.getCellRect(px, py)
              ctx.fillStyle = isCursor &amp;&amp; this.cursorBlink ?
                bb.inactiveColor :
                isInverted ? bb.textColor : bb.backColor
              boxBounds.fill(ctx)
              ctx.strokeStyle = 'black'
              if ((attr &amp; flags.HIDDEN) === 0) {
                ch[0] = this.chars[py][px]
                if (ch[0]) {
                  const dx = boxBounds.pos.x + (this.cellWidth - ctx.measureText(ch[0]).width) / 2
                  const dy = boxBounds.pos.y + ry

                  if (bb.shadow) {
                    // Render text shadow
                    const d = Math.max(1, bb.font.size / 10)
                    ctx.fillStyle = bb.shadowColor
                    ctx.fillText(ch[0], dx + d, dy + d)
                  }
                  // Render text
                  ctx.fillStyle = isInverted ? bb.backColor
                    : this.isAlternative() ? bb.alternativeColor : bb.textColor
                  ctx.fillText(ch[0], dx, dy)
                }
              }
              if (this.border || isMarked) {
                ctx.strokeStyle = bb.borderColor
                bb[isMarked ? 'markerStroke' : 'borderStroke'].setStroke(ctx)
                if (isMarked)
                  ctx.globalCompositeOperation = 'xor'

                // Draw border
                boxBounds.stroke(ctx)

                // Reset ctx default values
                if (isMarked)
                  ctx.globalCompositeOperation = 'source-over'
              }
              ctx.strokeStyle = 'black'
              AWT.Stroke.prototype.setStroke(ctx)
            }
          }
        }
      }
      return true
    }

    /**
     * Makes the cursor blink, alternating between two states. This method should be called only by
     * {@link TextGrid#cursorTimer}
     * @param {boolean} status
     */
    blink(status) {
      // TODO: Move blink and timer to ActivityPanel
      if (this.useCursor) {
        this.cursorBlink = status === 1 ? true : status === -1 ? false : !this.cursorBlink
        this.repaintCell(this.cursor.x, this.cursor.y)
      }
    }

    /**
     * Stops the cursor timer if not `null` and active
     */
    end() {
      if (this.cursorTimer) {
        this.cursorTimer.stop()
        this.cursorTimer = null
      }
    }
  }

  Object.assign(TextGrid.prototype, {
    /**
     * Number of rows
     * @name TextGrid#nRows
     * @type {number} */
    nRows: 1,
    /**
     * Number of columns
     * @name TextGrid#nCols
     * @type {number} */
    nCols: 1,
    /**
     * Two-dimension array of characters
     * @name TextGrid#chars
     * @type {string[][]} */
    chars: null,
    /**
     * Two-dimension array with the expected characters, used to check user's answers.
     * @name TextGrid#answers
     * @type {string[][]} */
    answers: null,
    /**
     * Two-dimension array of bytes used as containers of boolean attributes
     * @name TextGrid#attributes
     * @see TextGrid.flags
     * @type {number[][]} */
    attributes: null,
    /**
     * The cell width, in pixels
     * @name TextGrid#cellWidth
     * @type {number} */
    cellWidth: 20,
    /**
     * The cell height, in pixels
     * @name TextGrid#cellHeight
     * @type {number} */
    cellHeight: 20,
    /**
     * The preferred bounds of this grid
     * @name TextGrid#preferredBounds
     * @type {AWT.Rectangle} */
    preferredBounds: null,
    /**
     * The character to be used as wildcard
     * @name TextGrid#wild
     * @type {string} */
    wild: TextGridContent.prototype.wild,
    /**
     * Characters that can be used when randomizing the content of this grid
     * @name TextGrid#randomChars
     * @see TextGridContent#randomChars
     * @type {string} */
    randomChars: TextGridContent.prototype.randomChars,
    /**
     * Whether the blinking cursor is enabled or disabled
     * @name TextGrid#cursorEnabled
     * @type {boolean} */
    cursorEnabled: false,
    /**
     * Whether this grid uses a blinking cursor or not
     * @name TextGrid#useCursor
     * @type {boolean} */
    useCursor: false,
    /**
     * The current position of the cursor
     * @name TextGrid#cursor
     * @type {AWT.Point} */
    cursor: null,
    /**
     * `true` when the cursor is "blinking" (cell drawn with {@link BoxBase} `inverse` attributes)
     * @name TextGrid#cursorBlink
     * @type {boolean} */
    cursorBlink: false,
    /**
     * Controls the blinking of the cursor
     * @name TextGrid#cursorTimer
     * @type {AWT.Timer} */
    cursorTimer: null,
    /**
     * Whether the wildcard character is transparent or opaque
     * @name TextGrid#wildTransparent
     * @type {boolean} */
    wildTransparent: false,
  })

  /**
   * TextGrid default values
   * @name TextGrid.defaults
   * @constant
   * @type {object} */
  TextGrid.defaults = defaults

  /**
   * Binary flags used to mark status
   * @name TextGrid.flags
   * @constant
   * @type {object} */
  TextGrid.flags = flags

  return TextGrid
})
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
